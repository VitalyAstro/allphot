#!@BASH@
# -*-bash-*-
#  vim: ft=bash

# Where are our data?
@UPNAME@_DATA_PATH="@DATADIR@/@NAME@"

# Where are modules installed by default?
@UPNAME@_DEFAULT_MODULES_PATH="${@UPNAME@_DATA_PATH}/modules"

# Look in these places for modules
@UPNAME@_MODULES_PATH=( \
	"${HOME}/.@NAME@/modules" \
	"${@UPNAME@_DEFAULT_MODULES_PATH}" )

# Look in this place for libraries
@UPNAME@_CORE_PATH="${@UPNAME@_DATA_PATH}/libs"

# Look here for the default contents of a module
@UPNAME@_DEFAULT_ACTIONS="${@UPNAME@_CORE_PATH}/default.@NAME@"

# Our program name and version
@UPNAME@_VERSION="@VERSION@"
@UPNAME@_PROGRAM_NAME="@NAME@"

# Invocation information
@UPNAME@_BINARY_NAME="${0}"
@UPNAME@_KILL_TARGET="$$"

# Global options
@UPNAME@_OPTIONS=""

# Remove all alias definitions. Unset functions and variables that are
# known to cause trouble.
"unalias" -a
unset -f rm
unset CDPATH GLOBIGNORE
IFS=$' \t\n'

shopt -s extglob
shopt -s expand_aliases

# Load core functions
source "${@UPNAME@_CORE_PATH}/core.bash" || exit 255
# Load necessary functions for the main script
inherit output paths tests

# Sneaky trick to make die in subshells work. If you don't get
# it, don't ask...
trap 'echo "exiting" >&2; exit 250' 15

# Find and echo the filename of the foo module. If there's no foo module,
# die.
@NAME@_find_module() {
    local modname="$1" modpath="" modfile=""
    [[ -z ${modname} ]] && die "Usage: ${FUNCNAME} <module>"
    for modpath in "${@UPNAME@_MODULES_PATH[@]}" ; do
	[[ -f ${modpath}/${modname}.@NAME@ ]] && break
    done
    
    modfile="${modpath}/${modname}.@NAME@"
    [[ -r ${modfile} ]] || die -q "Can't load module ${modname}"
    echo ${modfile}
}

# Display usage
@NAME@_do_usage() {
    echo "Usage: ${PROGRAM_NAME} <global options> <module name> <module options>"
}

# Display help
@NAME@_do_help() {
    set_output_mode default
    @NAME@_do_usage
    echo
    @NAME@_do_list_options
    echo
    @NAME@_do_list_modules
}

# Display version
@NAME@_do_version() {
    echo "@NAME@ ${@UPNAME@_VERSION}"
}

# Display all recognized global options
@NAME@_do_list_options() {
    write_list_start "Global options:"
    write_kv_list_entry "--no-color,--no-colour"    "Disable coloured output"
}

# Display all available modules DEPRECATED
@NAME@_do_list_modules() {
    do_action modules list "$@"
}

### main code ###

# enable colour output and get width of terminal iff stdout is a tty
if [[ -t 1 ]]; then
    colours
    init_columns
else
    nocolours
fi

# figure out what the action is. we need to know whether we're
# invoked as a something-config/something-update.
action=""
for suffix in config update{,r} tool manager reader ; do
    if [[ ${0%%-${suffix}} != ${0} ]] ; then
	action=$(basename "${0}" )
	action=${action%%-${suffix}}
	break
    fi
done
unset suffix

if [[ -z ${action} ]] ; then
    binname=$(basename "${0}" )
    for prefix in config update{,r} manage 'read' ; do
	if [[ ${binname##${prefix}-} != ${binname} ]] ; then
	    action=$(basename "${0}" )
	    action=${action##${prefix}-}
	    break
	fi
    done
    unset binname prefix
fi

if [[ -z ${action} ]] && [[ -n ${1##--} ]] ; then
    while [[ ${1##--} != ${1} ]] ; do
	case ${1##--} in
	    brief)
		@UPNAME@_OPTIONS="${@UPNAME@_OPTIONS} brief"
		set_output_mode brief
		;;
	    no-colour|no-color)
		@UPNAME@_OPTIONS="${@UPNAME@_OPTIONS} no-colour"
		nocolours
		;;
	    help|version)
		action=${1##--}
		;;
	    *)
		die -q "Unknown option ${1}"
		;;
	esac
	shift
    done
    if [[ -z ${action} ]]; then
	action=${1}
	shift
    fi
fi

if [[ -n ${action} ]] ; then
    if is_function "@NAME@_do_${action//-/_}" ; then
	[[ $# -gt 0 ]] && die -q "Too many parameters"
	@NAME@_do_${action//-/_}
    else
	do_action "${action}" "$@"
    fi
else
    @NAME@_do_help
fi
